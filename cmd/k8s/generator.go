package k8s

import (
	"os"

	"github.com/spf13/cobra"
	"github.com/sumanmukherjee03/gotils/cmd/utils"
)

const (
	BINTRAY_TOKEN_SECRET  = "bintray_token_secret"
	GITHUB_TOKEN_SECRET   = "github_token_secret"
	DOCKER_CONFIG_SECRET  = "docker_config_secret"
	IMAGE_BUILDER_POD     = "image_builder_pod"
	ARTIFACT_BUILDER_POD  = "artifact_builder_pod"
	WEB_SERVER_DEPLOYMENT = "web_server_deployment"
	SERVICE               = "service"
)

var (
	generateK8sTemplateShortDesc = "Provides k8s template generation capability"
	generateK8sTemplateLongDesc  = `Lets you generate k8s templates.
		The templates generated by this tool can help you create various resources in a kubernetes cluster.`
	generateK8sTemplateExample = `
	### Available commands for k8s
	# gotils k8s generate TEMPLATE_KIND
	gotils k8s generate artifact_builder_pod -d $(pwd)/artifact_builder_pod.json`
	validK8sTemplates = map[string]bool{
		BINTRAY_TOKEN_SECRET:  true,
		GITHUB_TOKEN_SECRET:   true,
		DOCKER_CONFIG_SECRET:  true,
		IMAGE_BUILDER_POD:     true,
		ARTIFACT_BUILDER_POD:  true,
		WEB_SERVER_DEPLOYMENT: true,
		SERVICE:               true,
	}
	src                 string
	dest                string
	namespace           string
	builderImageName    string
	builderImageTag     string
	imageName           string
	imageTag            string
	appPort             int
	volumeImageName     string
	volumeImageTag      string
	volumeContainerPort int
	userId              int
	groupId             int
)

func NewK8sGenerator() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "generate TEMPLATE_KIND",
		Short:   generateK8sTemplateShortDesc,
		Long:    generateK8sTemplateLongDesc,
		Example: generateK8sTemplateExample,
		Args: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return utils.RaiseCmdErr(cmd, "Kind of k8s template not provided")
			}
			if len(args) > 1 {
				return utils.RaiseCmdErr(cmd, "Too many args")
			}
			if _, found := validK8sTemplates[args[0]]; !found {
				return utils.RaiseCmdErr(cmd, "Wrong type of k8s template provided")
			}
			return nil
		},
		TraverseChildren: true,
		Run: func(cmd *cobra.Command, args []string) {
			genTemplate(args[0])
		},
	}

	cmd.Flags().StringVarP(&src, "src", "s", "", "Full path to the input file")
	cmd.MarkFlagRequired("src")
	cmd.Flags().StringVarP(&dest, "dest", "d", "", "Full path to the output file")
	cmd.MarkFlagRequired("dest")
	cmd.Flags().StringVarP(&namespace, "namespace", "", "", "Namespace on which to perform the operations")
	cmd.MarkFlagRequired("namespace")
	cmd.Flags().StringVarP(&builderImageName, "builder-image", "", "", "Docker image name that builds the other docker images")
	cmd.Flags().StringVarP(&builderImageTag, "builder-image-tag", "", "", "Docker image tag for the image that builds other docker images")
	cmd.Flags().StringVarP(&imageName, "image", "", "", "Docker image name")
	cmd.Flags().StringVarP(&imageTag, "tag", "", "", "Docker image tag")
	cmd.Flags().IntVarP(&userId, "user-id", "", 1001, "User id the pod is supposed to run as")
	cmd.Flags().IntVarP(&groupId, "group-id", "", 1001, "Group id the pod is supposed to run as")
	cmd.Flags().IntVarP(&appPort, "port", "", 0, "Application port to be exposed")
	cmd.Flags().StringVarP(&volumeImageName, "volume-image", "", "", "Docker image name for the volume container")
	cmd.Flags().StringVarP(&volumeImageTag, "volume-tag", "", "", "Docker image tag for the volume container")
	cmd.Flags().IntVarP(&volumeContainerPort, "volume-port", "", 0, "Port to be exposed for the volume container")
	return cmd
}

////////////////////////// Unexported funcs //////////////////////////

func genTemplate(key string) {
	var input k8sTemplate
	switch key {
	case BINTRAY_TOKEN_SECRET:
		input = NewBintrayTokenSecretTemplate()
	case GITHUB_TOKEN_SECRET:
		input = NewGithubTokenSecretTemplate()
	case DOCKER_CONFIG_SECRET:
		input = NewDockerConfigSecretTemplate()
	case IMAGE_BUILDER_POD:
		input = NewImageBuilderTemplate()
	case ARTIFACT_BUILDER_POD:
		input = NewJobArtifactTemplate()
	case WEB_SERVER_DEPLOYMENT:
		input = NewWebServerDeployment()
	case SERVICE:
		input = NewServiceTemplate()
	}

	data, err := input.jsonOutput()
	if err != nil {
		utils.CheckErr(err.Error())
	}

	f, err := os.Create(dest)
	if err != nil {
		utils.CheckErr(err.Error())
	}
	defer f.Close()

	_, err = f.Write([]byte(data))
	if err != nil {
		utils.CheckErr(err.Error())
	}
}
